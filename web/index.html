<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semantic Search Demo</title>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({
            startOnLoad: true,
            theme: 'dark',
            themeVariables: {
                primaryColor: '#0066cc',
                primaryTextColor: '#e0e0e0',
                primaryBorderColor: '#0080ff',
                lineColor: '#909090',
                textColor: '#e0e0e0',
                mainBkg: '#0066cc',
                secondaryColor: '#2d2d2d',
                tertiaryColor: '#404040',
                noteBkgColor: '#3a3000',
                noteTextColor: '#ffc107',
                noteBorderColor: '#ffc107',
                actorBkg: '#2d2d2d',
                actorBorder: '#4da6ff',
                actorTextColor: '#e0e0e0',
                actorLineColor: '#909090',
                signalColor: '#e0e0e0',
                signalTextColor: '#e0e0e0',
                labelBoxBkgColor: '#0066cc',
                labelBoxBorderColor: '#0080ff',
                labelTextColor: '#e0e0e0',
                loopTextColor: '#e0e0e0',
                activationBkgColor: '#1a1a1a',
                activationBorderColor: '#4da6ff',
                sequenceNumberColor: '#e0e0e0'
            }
        });
    </script>
    <style>
        * {
            box-sizing: border-box;
        }

        label {
            color: #e0e0e0;
        }

        small {
            color: #909090;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        .container {
            background: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #e0e0e0;
            margin-top: 0;
            font-size: clamp(1.5rem, 5vw, 2rem);
        }

        h2 {
            color: #b0b0b0;
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            margin-top: 20px;
            margin-bottom: 15px;
        }

        .diagram-container {
            background: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
            overflow-x: auto;
        }

        .mermaid {
            display: flex;
            justify-content: center;
            background: transparent;
            border: none;
            padding: 0;
            margin: 0;
        }

        pre.mermaid {
            overflow: visible;
        }

        @media (max-width: 767px) {
            .diagram-container {
                padding: 10px;
            }
        }

        select {
            width: 100%;
            padding: 10px;
            border: 1px solid #404040;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
            margin-bottom: 10px;
            background: #1a1a1a;
            color: #e0e0e0;
            cursor: pointer;
        }

        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #404040;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
            margin-bottom: 10px;
            resize: vertical;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }

        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            flex: 1 1 auto;
            min-width: 150px;
            white-space: nowrap;
        }

        button:hover {
            background: #0080ff;
        }

        button:disabled {
            background: #404040;
            color: #808080;
            cursor: not-allowed;
        }

        #clearBtn {
            background: #505050;
        }

        #clearBtn:hover {
            background: #606060;
        }

        /* Polling indicator */
        #pollingIndicator {
            display: none;
            background: #3a3000;
            border: 1px solid #ffc107;
            border-radius: 4px;
            padding: 12px 15px;
            margin-bottom: 15px;
            align-items: center;
            gap: 10px;
            color: #ffc107;
        }

        #pollingIndicator.active {
            display: flex;
        }

        .polling-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #ffc107;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Tablet and larger screens */
        @media (min-width: 768px) {
            body {
                padding: 40px;
            }

            .container {
                padding: 30px;
            }
        }

        /* Mobile adjustments */
        @media (max-width: 767px) {
            button {
                font-size: 14px;
                padding: 10px 16px;
                min-width: unset;
                flex: 1 1 100%;
            }

            h1 {
                font-size: 1.5rem;
            }
        }

        #events {
            margin-top: 20px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 4px;
            min-height: 200px;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 13px;
            border: 1px solid #404040;
        }

        @media (max-width: 767px) {
            #events {
                font-size: 11px;
                padding: 10px;
            }
        }

        .event {
            margin: 8px 0;
            padding: 8px;
            border-left: 3px solid #0066cc;
            background: #2d2d2d;
        }

        .event.scheduled {
            border-color: #6c757d;
        }

        .event.started {
            border-color: #28a745;
        }

        .event.status {
            border-color: #ffc107;
        }

        .event.result {
            border-color: #17a2b8;
        }

        .event.error {
            border-color: #dc3545;
        }

        .event.retrieved {
            border-color: #6f42c1;
        }

        .event-type {
            font-weight: bold;
            color: #909090;
            text-transform: uppercase;
            font-size: 11px;
            margin-bottom: 4px;
        }

        .event-data {
            color: #e0e0e0;
            white-space: pre-wrap;
        }

        .result-item {
            margin: 4px 0;
            padding: 6px;
            background: #1a1a1a;
            border-radius: 3px;
            word-break: break-word;
            border: 1px solid #404040;
        }

        .similarity {
            font-weight: bold;
            color: #4da6ff;
        }

        @media (max-width: 767px) {
            .event {
                padding: 6px;
                margin: 6px 0;
            }

            .result-item {
                padding: 4px;
                font-size: 0.9em;
            }
        }

        /* Tab styles */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #404040;
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            color: #909090;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .tab:hover {
            color: #4da6ff;
        }

        .tab.active {
            color: #4da6ff;
            border-bottom-color: #4da6ff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        input[type="text"],
        input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #404040;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
            margin-bottom: 10px;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        @media (max-width: 767px) {
            .tabs {
                gap: 5px;
            }

            .tab {
                padding: 10px 16px;
                font-size: 14px;
            }
        }
    </style>
</head>

<body>
    <div class="diagram-container">
        <h2>Architecture Flow</h2>
        <pre class="mermaid">
sequenceDiagram
    participant UI as Browser UI
    box lightblue Proxy Service (python)
        participant Proxy as Python Proxy (8001)
        participant ProxyDapr as Proxy Dapr Sidecar
    end
    box lightsteelblue API Service (dotnet)
        participant APIDapr as API Dapr Sidecar
        participant API as Semantic Search API (5111)
        participant WF as Semantic Search Workflow
    end
    box lightyellow Semantic Search Service (python)
        participant Activity as Python Activity
    end

    UI->>Proxy: POST /semantic-search/stream
    Note over UI,Proxy: SSE Stream Initiated
    Proxy->>ProxyDapr: Dapr Service Invoke
    ProxyDapr->>APIDapr: HTTP Service-to-Service
    APIDapr->>API: Forward Request

    API->>WF: Schedule Workflow
    Note over API: SSE Event: scheduled
    API-->>UI: SSE: scheduled

    WF-->>API: Workflow Started
    Note over API: SSE Event: started
    API-->>UI: SSE: started

    WF->>Activity: Compute Embeddings Activity
    Activity-->>WF: Embeddings Result

    WF->>Activity: Calculate Similarity Activity
    Activity-->>WF: Similarity Results

    WF-->>API: Workflow Complete
    Note over API: SSE Event: result
    API-->>UI: SSE: result with data

    Note over API: SSE Event: done
    API-->>UI: SSE: done
    API-->>Proxy: Stream Complete
        </pre>
    </div>

    <div class="container">
        <h1>üîç Semantic Search</h1>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('new-search')">New Search</button>
            <button class="tab" onclick="switchTab('retrieve-results')">Retrieve Results</button>
        </div>

        <div id="new-search" class="tab-content active">
            <div>
                <label for="query"><strong>Query:</strong></label>
                <textarea id="query" rows="2"
                    placeholder="Enter your search query...">How do I reset my password?</textarea>
            </div>

            <div>
                <label for="documents"><strong>Documents (one per line):</strong></label>
                <textarea id="documents" rows="6" placeholder="Enter documents to search...">Steps to update your account password and recover access
Installing the mobile application on your device
Troubleshooting common login and authentication issues
Guide to configuring notification preferences
How to delete your account permanently</textarea>
            </div>

            <!-- Collapsible Settings -->
            <details class="dev-mode-panel" style="margin-bottom: 15px;">
                <summary style="cursor: pointer; font-weight: 600; padding: 12px; background: #1a1a1a; border-radius: 4px; user-select: none; border: 1px solid #404040;">
                    ‚öôÔ∏è Settings
                </summary>
                <div style="padding: 15px; border: 1px solid #404040; border-top: none; border-radius: 0 0 4px 4px; background: #2d2d2d;">
                    <div>
                        <label for="model"><strong>Model:</strong></label>
                        <select id="model">
                            <option value="all-MiniLM-L6-v2" selected>all-MiniLM-L6-v2 (Fast, 384d)</option>
                            <option value="all-MiniLM-L12-v2">all-MiniLM-L12-v2 (Balanced, 384d)</option>
                            <option value="all-mpnet-base-v2">all-mpnet-base-v2 (Best Quality, 768d)</option>
                            <option value="paraphrase-MiniLM-L3-v2">paraphrase-MiniLM-L3-v2 (Fastest, 384d)</option>
                            <option value="paraphrase-multilingual-MiniLM-L12-v2">paraphrase-multilingual-MiniLM-L12-v2 (Multilingual, 384d)</option>
                        </select>
                        <small style="display: block; color: #909090; margin-top: 5px;">
                            Select the embedding model to use for semantic search.
                        </small>
                    </div>
                    <div style="margin-top: 12px;">
                        <label for="sandbagSeconds"><strong>Artificial Delay (seconds):</strong></label>
                        <input type="number" id="sandbagSeconds" min="0" step="1" value="0" placeholder="0">
                        <small style="display: block; color: #909090; margin-top: 5px;">
                            Injects a delay before processing. Set to 10+ seconds to test interruptions by stopping services during the delay. Set to 0 to disable.
                        </small>
                    </div>
                </div>
            </details>

            <div class="button-group">
                <button id="searchBtn" onclick="startSearch()">
                    üîç Search Documents
                </button>
                <button id="clearBtn" onclick="clearEvents()">Clear Results</button>
            </div>
        </div>

        <div id="retrieve-results" class="tab-content">
            <div>
                <label for="workflowId"><strong>Workflow ID:</strong></label>
                <input type="text" id="workflowId" placeholder="Enter workflow ID (e.g., semantic-search-4e948545)">
            </div>

            <div class="button-group">
                <button id="retrieveBtn" onclick="retrieveResults()">
                    üì• Retrieve Results
                </button>
                <button id="clearRetrieveBtn" onclick="clearEvents()">Clear Results</button>
            </div>
        </div>

        <div id="pollingIndicator">
            <div class="polling-spinner"></div>
            <span><strong>Long Polling Active:</strong> Checking workflow status every 2 seconds...</span>
        </div>

        <div id="events"></div>
    </div>

    <script>
        let currentWorkflowId = null;  // Store workflowId for fallback polling
        let pollingInterval = null;    // Store polling interval ID
        let streamTimeoutChecker = null;  // Interval for checking stream timeout
        let lastEventTime = null;  // Timestamp of last received event
        let currentAbortController = null;  // AbortController for current fetch

        function switchTab(tabName) {
            // Remove active class from all tabs and content
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            // Add active class to selected tab and content
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');

            // Clear events when switching tabs
            clearEvents();

            // Stop any ongoing polling
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
        }

        function startSearch() {
            performSearch();
        }

        function performSearch() {
            // Reset workflow tracking
            currentWorkflowId = null;
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
            if (streamTimeoutChecker) {
                clearInterval(streamTimeoutChecker);
                streamTimeoutChecker = null;
            }

            // Get values from "New Search" tab
            const query = document.getElementById('query').value.trim();
            const documentsText = document.getElementById('documents').value.trim();
            const documents = documentsText.split('\n').filter(d => d.trim());
            const modelName = document.getElementById('model').value;

            // Always check sandbag value from "Dev Mode" tab
            const sandbagSeconds = parseInt(document.getElementById('sandbagSeconds').value) || 0;

            if (!query || documents.length === 0) {
                alert('Please provide a query and at least one document');
                return;
            }

            // Disable button
            const btn = document.getElementById('searchBtn');
            btn.disabled = true;
            const originalText = btn.innerHTML;
            btn.innerHTML = '‚è≥ Searching...';

            // Clear previous events
            clearEvents();

            // Build request body
            const requestBody = { query, documents, model_name: modelName };
            if (sandbagSeconds > 0) {
                requestBody.sandbag_seconds = sandbagSeconds;
                console.log(`[Dev Mode] ${sandbagSeconds}s artificial delay configured`);
            }

            // Create AbortController for this request
            currentAbortController = new AbortController();
            lastEventTime = Date.now();
            console.log(`[Timeout Setup] Starting stream with timeout detection. Initial time: ${new Date(lastEventTime).toISOString()}`);

            // Start timeout checker - if no events for 30 seconds, abort and fall back to polling
            streamTimeoutChecker = setInterval(() => {
                const timeSinceLastEvent = Date.now() - lastEventTime;
                console.log(`[Timeout Checker] Time since last event: ${timeSinceLastEvent}ms (threshold: 30000ms)`);
                if (timeSinceLastEvent >= 30000) {
                    console.log(`[Timeout Checker] Stream timeout detected! Aborting stream and falling back to polling...`);
                    clearInterval(streamTimeoutChecker);
                    streamTimeoutChecker = null;
                    currentAbortController.abort();
                }
            }, 5000); // Check every 5 seconds

            // Use fetch with streaming
            fetch('http://localhost:8001/semantic-search/stream', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'text/event-stream',
                },
                body: JSON.stringify(requestBody),
                signal: currentAbortController.signal
            })
                .then(response => {
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    let currentEvent = null;
                    let currentData = null;
                    let receivedResultEvent = false;  // Track if we got the "result" SSE event

                    function processText({ done, value }) {
                        if (done) {
                            // Clear timeout checker
                            if (streamTimeoutChecker) {
                                console.log('[Stream Complete] Stream ended from server');
                                clearInterval(streamTimeoutChecker);
                                streamTimeoutChecker = null;
                            }

                            // Check if stream ended prematurely (no "result" event received)
                            if (!receivedResultEvent && currentWorkflowId) {
                                console.log('[Stream Complete] Stream ended without "result" event - falling back to polling');
                                startPolling(currentWorkflowId, btn, originalText);
                                return;
                            }

                            btn.disabled = false;
                            btn.innerHTML = originalText;
                            return;
                        }

                        buffer += decoder.decode(value, { stream: true });
                        // Split by newline and handle both \n and \r\n line endings
                        const lines = buffer.split(/\r?\n/);
                        buffer = lines.pop() || '';

                        for (const line of lines) {
                            const trimmedLine = line.trim();

                            if (trimmedLine.startsWith('event:')) {
                                // If we have a pending event, emit it before starting new one
                                if (currentEvent !== null && currentData !== null) {
                                    handleEvent(currentEvent, currentData);
                                    // Track if we received the "result" event
                                    if (currentEvent === 'result') {
                                        receivedResultEvent = true;
                                    }
                                }
                                // Start new event
                                currentEvent = trimmedLine.substring(6).trim();
                                currentData = null;  // Use null to distinguish from empty data
                            } else if (trimmedLine.startsWith('data:')) {
                                // Only accumulate data if we have an active event
                                if (currentEvent !== null) {
                                    const dataLine = trimmedLine.substring(5).trim();
                                    // Concatenate multiple data lines per SSE spec
                                    if (currentData !== null) {
                                        currentData += '\n' + dataLine;
                                    } else {
                                        currentData = dataLine;
                                    }
                                }
                            } else if (trimmedLine === '') {
                                // Empty line signals end of event
                                if (currentEvent !== null && currentData !== null) {
                                    handleEvent(currentEvent, currentData);
                                    // Track if we received the "result" event
                                    if (currentEvent === 'result') {
                                        receivedResultEvent = true;
                                    }
                                    currentEvent = null;
                                    currentData = null;
                                }
                            }
                        }

                        return reader.read().then(processText);
                    }

                    return reader.read().then(processText);
                })
                .catch(error => {
                    console.error(`[Fetch Error] SSE streaming error: ${error.name} - ${error.message}`, error);

                    // Clear timeout checker on error
                    if (streamTimeoutChecker) {
                        console.log('[Fetch Error] Clearing timeout checker');
                        clearInterval(streamTimeoutChecker);
                        streamTimeoutChecker = null;
                    }

                    // If we have a workflowId, fall back to long polling
                    if (currentWorkflowId) {
                        console.log(`[Fetch Error] Falling back to polling for workflow: ${currentWorkflowId}`);
                        startPolling(currentWorkflowId, btn, originalText);
                    } else {
                        // No workflowId, can't poll - show error
                        console.log('[Fetch Error] No workflowId available, cannot fall back to polling');
                        addEvent('error', { message: `Stream failed: ${error.message}` });
                        btn.disabled = false;
                        btn.innerHTML = originalText;
                    }
                });
        }

        function startPolling(workflowId, btn, originalText) {
            console.log(`Starting polling for workflow: ${workflowId}`);

            // Show polling indicator
            document.getElementById('pollingIndicator').classList.add('active');

            let pollCount = 0;

            const poll = () => {
                pollCount++;
                console.log(`[${new Date().toISOString()}] Polling attempt #${pollCount} for workflow: ${workflowId}`);
                fetch(`http://localhost:8001/semantic-search/workflow/${workflowId}`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log(`Polling attempt #${pollCount} - status: ${data.status}`);

                        // Check if workflow is complete
                        if (data.status === 'Completed' && data.output) {
                            // Stop polling
                            if (pollingInterval) {
                                clearInterval(pollingInterval);
                                pollingInterval = null;
                            }

                            // Hide polling indicator
                            document.getElementById('pollingIndicator').classList.remove('active');

                            // Display results
                            addEvent('result', {
                                query: data.output.query,
                                results: data.output.results,
                                metadata: {
                                    device: data.output.device,
                                    processingTimeMs: data.output.totalProcessingTimeMs,
                                    embeddingDimension: data.output.embeddingDimension
                                }
                            });

                            // Re-enable button
                            btn.disabled = false;
                            btn.innerHTML = originalText;
                        } else if (data.status === 'Failed' || data.status === 'Terminated') {
                            // Stop polling on failure
                            if (pollingInterval) {
                                clearInterval(pollingInterval);
                                pollingInterval = null;
                            }

                            // Hide polling indicator
                            document.getElementById('pollingIndicator').classList.remove('active');

                            addEvent('error', {
                                message: `Workflow ${data.status.toLowerCase()}`,
                                status: data.status
                            });

                            // Re-enable button
                            btn.disabled = false;
                            btn.innerHTML = originalText;
                        } else {
                            // Still running, show status update
                            console.log(`Workflow still running: ${data.status}`);
                        }
                    })
                    .catch(error => {
                        console.error(`[${new Date().toISOString()}] Polling attempt #${pollCount} failed (will retry):`, error);
                        // Don't stop polling on error - service might come back online
                        // Error is logged to console; polling indicator banner shows polling is active
                    });
            };

            // Poll immediately, then every 2 seconds
            poll();
            pollingInterval = setInterval(poll, 2000);
        }

        function handleEvent(eventType, dataStr) {
            // Update last event time whenever we receive an event
            lastEventTime = Date.now();
            console.log(`[Event Handler] Received SSE event: ${eventType}, data length: ${dataStr.length}, reset timer at ${new Date(lastEventTime).toISOString()}`);

            // Heartbeat events are not displayed in UI, only logged
            if (eventType === 'heartbeat') {
                console.log(`[Heartbeat] Connection alive at ${new Date(lastEventTime).toISOString()}`);
                return;
            }

            try {
                const data = JSON.parse(dataStr);
                console.log(`Parsed event data:`, data);

                // Store workflowId for fallback polling
                if (eventType === 'scheduled' && data.workflowId) {
                    currentWorkflowId = data.workflowId;
                    console.log(`Stored workflowId for fallback: ${currentWorkflowId}`);
                }

                addEvent(eventType, data);
            } catch (e) {
                console.error('Failed to parse event data:', e);
                console.error('Raw data string:', dataStr);
                // Still try to display something
                addEvent('error', {
                    message: `Failed to parse ${eventType} event: ${e.message}`,
                    rawData: dataStr.substring(0, 200) + (dataStr.length > 200 ? '...' : '')
                });
            }
        }

        function addEvent(type, data) {
            try {
                console.log(`addEvent called: type=${type}`);
                const eventsDiv = document.getElementById('events');
                const eventDiv = document.createElement('div');
                eventDiv.className = `event ${type}`;

                const typeDiv = document.createElement('div');
                typeDiv.className = 'event-type';
                typeDiv.textContent = type;

                const dataDiv = document.createElement('div');
                dataDiv.className = 'event-data';

                // Format data based on event type
                if (type === 'result') {
                    console.log('Formatting result event with data:', data);
                    try {
                        let html = `<strong>Query:</strong> ${data.query}<br><br><strong>Results:</strong><br>`;
                        data.results.forEach((r, i) => {
                            html += `<div class="result-item">
                            ${i + 1}. <span class="similarity">${(r.similarity * 100).toFixed(2)}%</span> - ${r.document}
                            <br><small>(${r.interpretation})</small>
                        </div>`;
                        });
                        html += `<br><strong>Metadata:</strong><br>`;
                        html += `Device: ${data.metadata.device}, Time: ${data.metadata.processingTimeMs.toFixed(2)}ms, Dimension: ${data.metadata.embeddingDimension}`;
                        console.log('Built HTML for result:', html.substring(0, 100) + '...');
                        dataDiv.innerHTML = html;
                        console.log('Set innerHTML on dataDiv');
                    } catch (e) {
                        console.error('Error formatting result event:', e);
                        // Fallback to raw JSON if formatting fails
                        dataDiv.textContent = JSON.stringify(data, null, 2);
                    }
                } else {
                    dataDiv.textContent = JSON.stringify(data, null, 2);
                }

                eventDiv.appendChild(typeDiv);
                eventDiv.appendChild(dataDiv);
                eventsDiv.appendChild(eventDiv);
                console.log(`Appended ${type} event to DOM. Total events now:`, eventsDiv.children.length);
            } catch (e) {
                console.error('Error adding event to display:', e, type, data);
            }
        }

        function retrieveResults() {
            const workflowId = document.getElementById('workflowId').value.trim();

            if (!workflowId) {
                alert('Please provide a workflow ID');
                return;
            }

            // Disable button
            const btn = document.getElementById('retrieveBtn');
            btn.disabled = true;
            const originalText = btn.innerHTML;
            btn.innerHTML = '‚è≥ Retrieving...';

            // Clear previous events
            clearEvents();

            // Fetch workflow results
            fetch(`http://localhost:8001/semantic-search/workflow/${workflowId}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Display workflow info
                    addEvent('retrieved', {
                        workflowId: data.workflowId,
                        status: data.status,
                        createdAt: data.createdAt
                    });

                    // If workflow is completed, show results
                    if (data.status === 'Completed' && data.output) {
                        addEvent('result', {
                            query: data.output.query,
                            results: data.output.results,
                            metadata: {
                                device: data.output.device,
                                processingTimeMs: data.output.totalProcessingTimeMs,
                                embeddingDimension: data.output.embeddingDimension
                            }
                        });
                    } else {
                        addEvent('status', {
                            message: `Workflow status: ${data.status}`,
                            customStatus: data.customStatus
                        });
                    }

                    btn.disabled = false;
                    btn.innerHTML = originalText;
                })
                .catch(error => {
                    console.error('Error:', error);
                    addEvent('error', { message: error.message });
                    btn.disabled = false;
                    btn.innerHTML = originalText;
                });
        }

        function clearEvents() {
            document.getElementById('events').innerHTML = '';

            // Stop any ongoing polling
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
                console.log('Stopped polling on clear');
            }

            // Hide polling indicator
            document.getElementById('pollingIndicator').classList.remove('active');

            // Reset workflow tracking
            currentWorkflowId = null;
        }
    </script>
</body>

</html>